<!DOCTYPE html>
<html>
<head>
    <title>Guitar Fretboard Custom Triad Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; }
        #controls { margin: 20px; display: flex; gap: 20px; }
        #fretboard { background-color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .fret { stroke: #333; stroke-width: 2; }
        .note-label { font-size: 12px; fill: white; pointer-events: none; }
        #legend {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            justify-content: center;
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="controls">
        <p>key-select</p>
        <select id="key-select">
            <option>C</option><option>C#</option><option>D</option><option>D#</option>
            <option>E</option><option>F</option><option>F#</option><option>G</option>
            <option>G#</option><option>A</option><option>A#</option><option>B</option>
        </select>
        <p>display-type</p>
        <select id="display-type">
            <option>name</option>
            <option>interval</option>
        </select>
        <p>triad-select</p>
        <select id="triad-select">
            <option></option>
            <option>Mayor</option>
            <option>Menor</option>
        </select>
        <p>chord-type</p>
        <select id="chord-type">
            <option></option>
            <option>Septima menor</option>
        </select>
        <p>scale-select</p>
        <select id="scale-select">
            <option></option>
            <option>Mayor</option>
            <option>Menor Natural</option>
            <option>Pentatónica Mayor</option>
            <option>Pentatónica Menor</option>
            <option>Blues</option>
        </select>
    </div>
    <svg id="fretboard" width="850" height="300"></svg>
    <div id="legend" style="margin-top: 20px; background-color: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
            <h3 style="margin: 0 0 10px 0; border-bottom: 2px solid #eee; padding-bottom: 5px; width: 100%; text-align: center;">Leyenda</h3>
            <div style="display: flex; gap: 20px;">
                <!-- Los grupos se añadirán aquí -->
            </div>
        </div>
     </div>

    <script>
        const strings = ['E', 'B', 'G', 'D', 'A', 'E'];
        const chromaticNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const intervals = {
            'T': 0,  // Tónica
            '2m': 1, // Segunda menor
            '2M': 2, // Segunda mayor
            '3m': 3, // Tercera menor
            '3M': 4, // Tercera mayor
            '4J': 5, // Cuarta justa
            '5J': 7, // Quinta justa
            '6m': 8, // Sexta menor
            '6M': 9, // Sexta mayor
            '7m': 10, // Séptima menor
            '7M': 11  // Séptima mayor
        };
        // Add to existing intervals
        const scales = {
            'Mayor': [0, 2, 4, 5, 7, 9, 11],
            'Menor Natural': [0, 2, 3, 5, 7, 8, 10],
            'Pentatónica Mayor': [0, 2, 4, 7, 9],
            'Pentatónica Menor': [0, 3, 5, 7, 10],
            'Blues': [0, 3, 5, 6, 7, 10]
        };


        const svg = d3.select("#fretboard");
        const keySelect = d3.select("#key-select");
        const triadSelect = d3.select("#triad-select");
        const chord7Select = d3.select("#chord-type");
        //const selectedChord = d3.select("#chord-type").property('value');
        const scaleSelect = d3.select("#scale-select");
        const width = 850, height = 300, numFrets = 14, numStrings = 6;
        const svgMargin = 40; // Margen izquierdo
        const effectiveWidth = width - (svgMargin * 2); // Margen en ambos lados; // Ancho efectivo para el dibujo
        const fretWidth = effectiveWidth / (numFrets + 1);
        const stringSpacing = height / (numStrings + 1);

        const triadColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FDCB6E', '#6C5CE7', '#A8E6CF',
            '#FF9F43', '#10AC84', '#5F27CD', '#FF6B81', '#1DD1A1', '#48DBFB',
            '#576574', '#341F97', '#8395A7', '#01A3A4'
        ];

        // Get interval name from its value
        function getIntervalName(value) {
            const intervalNames = {
                0: 'T', 2: '2M', 4: '3M', 5: '4J',
                7: '5J', 9: '6M', 11: '7M',
                1: '2m', 3: '3m', 6: '4A',
                8: '6m', 10: '7m'
            };
            return intervalNames[value];
        }

        function drawFretboard() {
            svg.selectAll("*").remove();

             // Draw dots at frets 3, 5, 7, 9, and 12
            const dotFrets = [3, 5, 7, 9, 12];
            dotFrets.forEach(fret => {
                if (fret === 12) {
                    svg.append('circle')
                        .attr('cx', svgMargin +(fret * fretWidth)-30)
                        .attr('cy', height - 8)
                        .attr('r', 8)
                        .attr('fill', '#888');
                    svg.append('circle')
                        .attr('cx', svgMargin +(fret * fretWidth)-30)
                        .attr('cy', height - 28)
                        .attr('r', 8)
                        .attr('fill', '#888');
                } else {
                    svg.append('circle')
                        .attr('cx', svgMargin +(fret * fretWidth)-30)
                        .attr('cy', height - 18)
                        .attr('r', 8)
                        .attr('fill', '#888');
                }
            });

            // Draw thicker first fret line (nut)
            svg.append('line')
                .attr('x1', svgMargin)
                .attr('y1', stringSpacing)
                .attr('x2', svgMargin)
                .attr('y2', height - stringSpacing)
                .attr('stroke', '#000')
                .attr('stroke-width', 4);

            // Draw remaining frets
            for (let i = 1; i <= numFrets; i++) {
                svg.append('line')
                    .attr('x1', svgMargin + i * fretWidth)
                    .attr('y1', stringSpacing)
                    .attr('x2', svgMargin + i * fretWidth)
                    .attr('y2', height - stringSpacing)
                    .attr('class', 'fret');
            }

            // Draw 6 strings with varying thickness
            for (let j = 0; j < numStrings; j++) {
                svg.append('line')
                    .attr('x1', svgMargin)
                    .attr('y1', (j + 1) * stringSpacing)
                    .attr('x2', width - svgMargin)
                    .attr('y2', (j + 1) * stringSpacing)
                    .attr('stroke', '#888')
                    .attr('stroke-width', (6-j) * 0.3);
            }

            const selectedKey = keySelect.property('value');
            const selectedTriad = triadSelect.property('value');
            //const displayType = d3.select("#display-type");
            const selectedChord7 = d3.select("#chord-type").property('value');
            const selectedScale = document.getElementById('scale-select').value;
            const selectedDisplayType = d3.select("#display-type").property('value');
            const keyIndex = chromaticNotes.indexOf(selectedKey);

            // Triad interval configuration based on triad type
            const triadIntervals = {
                'Mayor': ['3M', '5J'],
                'Menor': ['3m', '5J']
            }[selectedTriad];

            //let formations = [];
            let formation_groups = [];
                if (selectedChord7 === 'Septima menor') {
                    formation_groups = [{
                        groupName: "Posiciones de Séptima",
                        color: '#45B7D1',
                        formations: [{
                            mapping: [
                                {string: 0, interval: 'T'},
                                {string: 1, interval: selectedTriad === 'Mayor' ? '3M' : '3m'},
                                {string: 2, interval: '5J'},
                                {string: 3, interval: '7m'}
                            ]
                        },
                        {
                            mapping: [
                                {string: 0, interval: '7m'},
                                {string: 1, interval: selectedTriad === 'Mayor' ? '3M' : '3m'},
                                {string: 2, interval: '5J'},
                                {string: 3, interval: 'T'}
                            ]
                        }]
                    }];
                } else if (selectedTriad !== ''){
                    formation_groups = [{
                        groupName: "Tríadas Primera Inversión",
                        color: '#FF6B6B',
                        formations: [{
                                mapping: [
                                    {string: 0, interval: 'T'},
                                    {string: 1, interval: '5J'},
                                    {string: 2, interval: selectedTriad === 'Mayor' ? '3M' : '3m'}
                                ]
                            },
                            {
                                mapping: [
                                    {string: 1, interval: 'T'},
                                    {string: 2, interval: '5J'},
                                    {string: 3, interval: selectedTriad === 'Mayor' ? '3M' : '3m'}
                                ]
                            },
                            {
                                mapping: [
                                    {string: 2, interval: 'T'},
                                    {string: 3, interval: '5J'},
                                    {string: 4, interval: selectedTriad === 'Mayor' ? '3M' : '3m'}
                                ]
                            },
                            {
                                mapping: [
                                    {string: 3, interval: 'T'},
                                    {string: 4, interval: '5J'},
                                    {string: 5, interval: selectedTriad === 'Mayor' ? '3M' : '3m'}
                                ]
                            }
                        ]
                    },
                    {
                        groupName: "Tríadas Segunda Inversión ",
                        color: '#4ECDC4',
                        formations: [{
                                mapping: [
                                    {string: 0, interval: selectedTriad === 'Mayor' ? '3M' : '3m'},
                                    {string: 1, interval: 'T'},
                                    {string: 2, interval: '5J'}
                                ]
                            },
                            {
                                mapping: [
                                    {string: 1, interval: selectedTriad === 'Mayor' ? '3M' : '3m'},
                                    {string: 2, interval: 'T'},
                                    {string: 3, interval: '5J'}
                                ]
                            },
                            {
                                mapping: [
                                    {string: 2, interval: selectedTriad === 'Mayor' ? '3M' : '3m'},
                                    {string: 3, interval: 'T'},
                                    {string: 4, interval: '5J'}
                                ]
                            },
                            {
                                mapping: [
                                    {string: 3, interval: selectedTriad === 'Mayor' ? '3M' : '3m'},
                                    {string: 4, interval: 'T'},
                                    {string: 5, interval: '5J'}
                                ]
                            }
                        ]
                    }
                
                
                    ];
                }
            
            // Crear un mapa para registrar las notas y sus grupos
            let noteMap = new Map(); // clave: "string-fret", valor: array de grupos

            formation_groups.forEach((group) => { 
                group.formations.forEach(formation => {
                    const formationPositions = [];
                    formation.mapping.forEach((map, index) => {
                        let found = false;
                        let bestFret = 0;
                        let minDistance = Infinity;
                        let shouldStartFrom12 = false;

                        // Si es la primera nota, comprobamos si debería empezar desde el 12
                        if (index === 0) {
                            for (let fret = 0; fret <= numFrets; fret++) {
                                const note = getNoteAtPosition(strings[map.string], fret);
                                const intervalValue = intervals[map.interval];
                                const expectedNote = chromaticNotes[(keyIndex + intervalValue) % 12];

                                if (note === expectedNote) {
                                    // Comprobamos las notas siguientes
                                    let sumDistanceTo1 = 0;
                                    let sumDistanceTo12 = 0;

                                    formation.mapping.slice(1).forEach(nextMap => {
                                        // Encontrar las posiciones más cercanas a 1 y a 12 para cada nota siguiente
                                        let minDistTo1 = Infinity;
                                        let minDistTo12 = Infinity;

                                        for (let nextFret = 0; nextFret <= numFrets; nextFret++) {
                                            const nextNote = getNoteAtPosition(strings[nextMap.string], nextFret);
                                            const nextIntervalValue = intervals[nextMap.interval];
                                            const nextExpectedNote = chromaticNotes[(keyIndex + nextIntervalValue) % 12];

                                            if (nextNote === nextExpectedNote) {
                                                minDistTo1 = Math.min(minDistTo1, Math.abs(nextFret - 1));
                                                minDistTo12 = Math.min(minDistTo12, Math.abs(nextFret - 12));
                                            }
                                        }
                                        sumDistanceTo1 += minDistTo1;
                                        sumDistanceTo12 += minDistTo12;
                                    });

                                    if (sumDistanceTo12 < sumDistanceTo1) {
                                        shouldStartFrom12 = true;
                                    }
                                    break;
                                }
                            }
                        }

                        for (let fret = 0; fret <= numFrets; fret++) {
                            const note = getNoteAtPosition(strings[map.string], fret);
                            const intervalValue = intervals[map.interval];
                            const expectedNote = chromaticNotes[(keyIndex + intervalValue) % 12];

                            if (note === expectedNote) {
                                if (index === 0) {
                                    const selectedFret = shouldStartFrom12 ? 12 : fret;
                                    formationPositions.push({
                                        string: map.string,
                                        fret: selectedFret,
                                        interval: map.interval,
                                        note: note
                                    });
                                    found = true;
                                    break;
                                } else {
                                    const distance = Math.abs(fret - formationPositions[index - 1].fret);
                                    if (distance < minDistance) {
                                        minDistance = distance;
                                        bestFret = fret;
                                    }
                                }
                            }
                        }

                        if (!found && index > 0) {
                            formationPositions.push({
                                string: map.string,
                                fret: bestFret,
                                interval: map.interval,
                                note: getNoteAtPosition(strings[map.string], bestFret)
                            });
                        }
                    });
                    //console.log('Nuevo formation!!');
                    //console.log('formationPositions->', JSON.stringify(formationPositions, null, 2));
                    //console.log('formation->', JSON.stringify(formation, null, 2));

                    if (formationPositions.length === formation.mapping.length) {

                        // Dibujar solo las líneas
                        for (let i = 0; i < formationPositions.length - 1; i++) {
                            svg.append('line')
                                .attr('x1', svgMargin + formationPositions[i].fret * fretWidth)
                                .attr('y1', (formationPositions[i].string + 1) * stringSpacing)
                                .attr('x2', svgMargin + formationPositions[i+1].fret * fretWidth)
                                .attr('y2', (formationPositions[i+1].string + 1) * stringSpacing)
                                .attr('stroke', group.color)
                                .attr('stroke-width', 3)
                                .attr('fill', 'none')
                                .attr('opacity', 0.7)
                                .attr('fill', 'none')
                                .attr('data-group', group.groupName); // Add a data attribute for identification if needed
                        }
                        
                        formationPositions.forEach(pos => {
                            //ejemplos de la key: 0-12  1-6 ..
                            const key = `${pos.string}-${pos.fret}`;
                            if (!noteMap.has(key)) {
                                noteMap.set(key, []);
                            }
                            noteMap.get(key).push({
                                group: group,
                                position: pos
                            });
                        });
                            // Print noteMap contents
                            /*console.log('NoteMap contents:', Array.from(noteMap.entries()).map(([key, value]) => ({
                                key, 
                                value: value.map(item => ({
                                    groupName: item.group.groupName,
                                    position: item.position
                                }))
                            })));
                            */
                            //end print
                    }
                });
            });

            // Dibujar círculos concéntricos para cada nota
            noteMap.forEach((groupsInfo, key) => {
                const [string, fret] = key.split('-').map(Number);
                const pos = groupsInfo[0].position;
                console.log('string->', JSON.stringify(string, null, 2));
                console.log('fret->', JSON.stringify(fret, null, 2));
                console.log('pos->', JSON.stringify(pos, null, 2));
                 // Dibujar círculos concéntricos
                 groupsInfo.reverse().forEach((info, index) => {
                    console.log('info->', JSON.stringify(info, null, 2));

                    svg.append('circle')
                        .attr('cx', svgMargin + fret * fretWidth)
                        .attr('cy', (string + 1) * stringSpacing)
                        .attr('r', 15 - (index * 5))
                        .attr('fill', info.group.color);
                });

                // Texto de la nota
                svg.append('text')
                    .attr('x', svgMargin + fret * fretWidth)
                    .attr('y', (string + 1) * stringSpacing)
                    .attr('text-anchor', 'middle')
                    .attr('dy', 5)
                    .attr('class', 'note-label')
                    .attr('fill', 'white')
                    .text(selectedDisplayType === 'name' ? pos.note : pos.interval);
            });
        //        });
        //    });//End formation

            //Legend
            const legend = d3.select("#legend").select("div").select("div");
            legend.selectAll("*").remove();

            formation_groups.forEach(group => {
            const groupDiv = legend.append("div")
                .style("display", "flex")
                .style("align-items", "center")
                .style("gap", "10px");

            groupDiv.append("div")
                .style("width", "15px")
                .style("height", "15px")
                .style("border-radius", "50%")
                .style("background-color", group.color);

            groupDiv.append("div")
                .style("font-weight", "bold")
                .text(group.groupName);
            });

            //Paint scales
            if(selectedScale !== '') {
                const scaleIntervals = scales[selectedScale];
                strings.forEach((openNote, stringIndex) => {
                    for (let fret = 0; fret <= numFrets; fret++) {
                        const note = getNoteAtPosition(openNote, fret);
                        const intervalValue = (chromaticNotes.indexOf(note) - keyIndex + 12) % 12;
                        const isScaleNote = scaleIntervals.includes(intervalValue);

                        if (isScaleNote) {
                            svg.append('circle')
                                .attr('cx', svgMargin + fret * fretWidth)
                                .attr('cy', (stringIndex + 1) * stringSpacing)
                                .attr('r', 15)
                                .attr('fill', '#4ECDC4');


                            const displayText = selectedDisplayType === 'name' ? note : getIntervalName(intervalValue);

                            svg.append('text')
                                .attr('x', svgMargin + fret * fretWidth)
                                .attr('y', (stringIndex + 1) * stringSpacing)
                                .attr('text-anchor', 'middle')
                                .attr('dy', 5)
                                .attr('class', 'note-label')
                                .attr('fill', 'white')
                                .text(displayText);
                        }
                    }
                });
            }
        }

        function getNoteAtPosition(openNote, fret) {
            const startIndex = chromaticNotes.indexOf(openNote);
            const noteIndex = (startIndex + fret) % 12;
            return chromaticNotes[noteIndex];
        }

        drawFretboard();
        keySelect.on('change', drawFretboard);
        triadSelect.on('change', drawFretboard);
        d3.select("#chord-type").on('change', drawFretboard);
        d3.select("#display-type").on('change', drawFretboard);
        scaleSelect.on('change', drawFretboard);
        //displayType.on('change', drawFretboard);
    </script>
</body>
</html>
